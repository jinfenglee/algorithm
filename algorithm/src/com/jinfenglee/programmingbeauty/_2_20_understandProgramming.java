package com.jinfenglee.programmingbeauty;

/**
 * 编程之美2.20 程序理解和时间分析
 * 
 * @author LJF
 * @date 2014-07-22 07:34:00
 * 
 */
public class _2_20_understandProgramming {

	public static void main(String[] args) {

		int rg[] = { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
				18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 };
		
		for (Long i = 2123581660200L; i < Long.MAX_VALUE; i++) {
			int hit = 0;
			int hit1 = -1;
			int hit2 = -1;
			
			/**
			 * 只要找出了3个不能整除的数，这个for循环就结束了. 
			 * 必须刚好从30个数里面找到2个连续的数不能整除。
			 */
			for (int j = 0; j < rg.length && (hit <= 2); j++) {
				if ((i % rg[j]) != 0) {
					hit++;
					if (hit == 1) {
						hit1 = j;
					} else if (hit == 2) {
						hit2 = j;
					} else
						break;
				}
			}
			
			if ((hit == 2) && (hit1 + 1 == hit2)) {
				System.out.println("find:  " + i);
				break;
			}
		}
	}

	/**
	 * 符合条件的数为：某个数不能且仅不能被2~31 之间两个相邻数整除, 但能被其它28个数整除. 
	 * 因而这个值是其他28个数公倍数的整数倍.
	 * 
	 * i不能被相邻的两个数整除，必然是分解质因子后要么i的质因子中不包括这两个数的质因子，
	 * 要么是i的质因子的次数小于这两个数中相同质因子的次数。
	 * 那么，只需要给2-31这30个数分解质因数，找一下是否有这样的相邻的两个数，
	 * 要么它们的质因子中有其它数没有的质因子，要么对于相同的一个质因子，
	 * 这两个数包含这个质因子的次数高于其它所有次数。
	 * 
	 * 16、17、19、23、25、27、29、31这几个数包含次数最高的质因子。而相邻的则只有16，17。
	 * 这个个最小的i是：2^3*3^3*5^2*7*11*13*19*23*29*31
	 * 
	 */
}
